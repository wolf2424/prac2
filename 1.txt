dna_sequence = open(r"F:\BE\My Cl2\B1\dna_sequence.txt").read().strip()
print("DNA sequence:", dna_sequence)

gc_content = (dna_sequence.count("G") + dna_sequence.count("C")) / len(dna_sequence) * 100
print("GC Content:", gc_content, "%")

motif = "CGT"
motif_positions = [i for i in range(len(dna_sequence)) if dna_sequence.startswith(motif, i)]
print("Motif", motif, "found at positions:", motif_positions)

start_codon = "ATG"
stop_codons = ["TAA", "TAG", "TGA"]
coding_regions = []

for i in range(len(dna_sequence) - 2):
    if dna_sequence[i:i + 3] == start_codon:
        for j in range(i + 3, len(dna_sequence) - 2, 3):
            if dna_sequence[j:j + 3] in stop_codons:
                coding_regions.append((i, j + 3))
                break

if coding_regions:
    print("Coding regions found:")
    for start, end in coding_regions:
        print("Start:", start, "End:", end, "Sequence:", dna_sequence[start:end])
else:
    print("No coding regions found.")


#optional
print("Summary of DNA Sequence Analysis:")
print("GC Content:", gc_content, "%")
print("Motif positions:", motif_positions)
print("Coding regions:", coding_regions)

Code Explanation

Loading and Displaying DNA Sequence:
The DNA sequence is loaded from a text file, stripped of any whitespace, and printed. The r prefix in the file path treats it as a raw string, allowing special characters in file paths without escaping them.

Calculating GC Content:
GC content is a measure of the proportion of guanine (G) and cytosine (C) in the sequence. It's calculated as the number of G and C bases divided by the sequence length, multiplied by 100 to get a percentage.

Finding Motif Positions:
This section searches for occurrences of the motif “CGT” within the DNA sequence. It iterates over the sequence and uses the startswith method to check if the substring at each position matches the motif.This section searches for occurrences of the motif “CGT” within the DNA sequence. It iterates over the sequence and uses the startswith method to check if the substring at each position matches the motif.


Identifying Coding Regions:
Coding regions typically begin with a start codon ("ATG") and end with one of the stop codons ("TAA", "TAG", or "TGA"). This code identifies coding regions by finding start-stop codon pairs and appends their start and end positions to coding_regions.

Summary of Analysis:
This optional section prints a summary of the analysis results, including GC content, motif positions, and identified coding regions.


Theory
What is GC content, and why is it important?
GC content represents the percentage of guanine and cytosine bases in a DNA sequence. It’s important because GC-rich regions tend to be more stable due to the triple hydrogen bonds between G and C, compared to the double bonds in AT pairs. GC content can impact the DNA's melting temperature and the stability of the sequence.

How does this code identify coding regions in the DNA sequence?
he code identifies coding regions by locating the start codon ("ATG") and then searching for the nearest stop codon ("TAA," "TAG," or "TGA") downstream. When a start-stop pair is found, it’s considered a coding region, and the code stores the start and end indices of that region.

Why do we use the startswith method to find motifs?
The startswith method is used because it efficiently checks if the substring starting at a specific position matches the motif. This is faster and more concise than manually comparing each substring to the motif.

What does the code do if no coding regions are found?
f no coding regions are found, the code outputs "No coding regions found." This avoids errors and provides feedback if there are no matches for the start or stop codons.

Why do we multiply the GC content calculation by 100?
Multiplying by 100 converts the GC content from a fraction to a percentage, making it easier to interpret.

Can this code handle lowercase DNA sequences?
No, it only works with uppercase sequences because it specifically counts "G" and "C" and checks for uppercase motifs like "CGT." To handle lowercase, we could use dna_sequence.upper() at the beginning.

How could you modify the code to find a different motif in the sequence?
To search for a different motif, simply change the motif variable to the desired sequence. The rest of the code will automatically search for that motif in the sequence.